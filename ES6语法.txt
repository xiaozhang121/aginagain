ES6语法:
let  与 var 区别:
1不能重复定义
2没有遍历提升,必须先定义再使用(没有预解析)
3全局变量不会附加到window对象的属性中
4具有块级作用域(
代码块:
if(){}else{}else if{};
swithch(){}"9"
for(){}
while(){}
function(){}

var obj = {}不是代码块/除了对象字面量的之外带大括号的都是代码块;
)
自调用函数作用:模块化代码,相当于创建块级作用域:

const常量:名称全大写 多部分用_连接
1const不能重新赋值;
2const声明常量时必须设置初始值;
具有块作用域 不能重复声明  不能称为window成员 声明之前不能访问
3const可以改变复杂数据类型对象中的属性
4冻结操作:如果希望某个对象完全无法修改,使用const+freeze()操作
Object.freeze(对象名);/冻结只是对象的属性无法修改 属性的属性还是可以修改;

解构赋值:,
左右解构需要对应 左侧表示要声明的变量 赋值为右侧对应的元素
var arr = [1,2,3,4];

var [a,b,c,d]=arr;

log(a,b,c,d);
                                
左右数据个数不对应 左侧多了则是undefined /如果某项不取 用逗号隔开
解构赋值设置默认值后 如果可以取到值那么就使用取到的值 如果没有取到就使用默认值
剩余值:    ...c 必须为最后一个 形式为一个数组

解构数组 数组中如果还有数组 那么解构的格式中也要带有数组框

对象解构赋值:无序的 名称对应就可以 /无需用都好分隔,直接写属性名就可以
属性别名可以在变量名后面加:+属性别名=',默认值'  属性别名才是最后的变量名/ 先写别名再写默认值

var obj = {
sayHi:function(){
log(xxx);
},
ES6新写法:
sayHe(){
log(xxx);
}
}

a && b

只要 && 前面是 false，无论 && 后面是true还是 false，结果都将返 && 前面的值;
只要 && 前面是 true，无论 && 后面是true还是 false，结果都将返 && 后面的值;

a || b

只要 || 前面为 false，无论 || 后面是true还是 false，结果都返回 || 后面的值。
只要 || 前面为 true，无论 || 后面是true还是 false，结果都返回 || 前面的值。

关键字可以当属性名不能当变量名 class if ...

2.------------------------------------------------------------------------------------------------------------------------
箭头函数的使用:
 var fun = (num, num2, num3) => {
            console.log(1);
            console.log(num, num2, num3);
        };
        fun(10, 20, 30);
        返回值的使用/可以忽略大括号和return
        var fun = (num1, num2) => num1 + num2;
        console.log(fun(10, 20));
        var arr = [1, 2, 3, 4, 5];
        arr.sort((a, b) => a - b);
        console.log(arr);

箭头函数中没有argument,可以使用剩余值...进行操作;
var fun = (...other)=>{
log(other);
}
fun(1,2,3);

this是js中特殊的标识符 根据使用环境变化自动改变
1全局作用域中this是window 
2局部作用域中this(函数内):
-普通函数调用(fun(1,2,3))是window
-作为方法调用的函数:是当前对象
-通过call apply bind修改过的this:是设置的对象:obj.sayHi.call/apply(obj2);----bind不调用

箭头函数中没有单独的this,如果内部使用this,指的是箭头环境所处环境中的this 在所处环境中不会改变指向
箭头函数无法作为构造函数使用/只可以作为匿名函数的代码封装使用
由于箭头函数是作为对象字面量的属性定义的,对象字面量在全局代码中定义,因此,箭头函数内部的this值与全局函数的this值相同
3.--------------------------------------------------------------------------------------------------------------------------
**********************Array**********************
数组的新功能:

1扩展运算符(展开运算符);
在数组前面设置... 表示将数组展开 对元素进行操作;
区分:在解构和函数形参列表中设置的...都是剩余值功能/在其他位置对数组使用是扩展运算符;
...arr;

2数组合并
var arr3=[...arr1,...arr2];

3Math.max();
Math.max(...arr);             参数为多个数字 不能为数组/需使用...将数组展开

4.Array.from();
将其他伪数组对象转换成数组
定义一个伪数组 然后通过Array.from()将其转换成为数组
let fakeArr = {
            0: 'a',
            1: 'b',
            2: 'c',
            length: 3
        };
console.log(Array.from(fakeArr));

5.find方法(返回的是要查找的元素)/findIndex(返回的是下标):
let result = [1,2,3,4].find(function(item,index,self){
item  数组中每一个值;
index 数组中每个索引;
self 当前数组
return item;
})
相当于for in

6.includes()/字符串也有这个方法 功能一样(字符串需要加引号);
用法:
var arr = [1,2,3,4];
log(arr.include(4);) 返回值为布尔值 
相当于查找 indexof();
4.-----------------------------------------------------------------------------------------------------------------------------
*********************************Set********************************
数组去除重复
let set = new set([1,2,3,4,4,4,4,4,4,4,4]);
log(set);

.size 获取成员个数 属性相当于length;

.add(value); 向set中添加元素 返回set结构本身

.delete();删除某个值 返回的是布尔值

.has(); 表示set中是否有该元素 返回一个布尔值

.clear(); 清除所有成员 没有返回值

forEach:遍历;Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：

[...new set(arr)]数组去重
5.------------------------------------------------------------------------------------------------------------------------------------
*****************************String****************************************
str.includes(要搜索的元素,[position]从第几个索引开始);
返回值为布尔值;

str.startsWith(表示该字符是否在头部或者指定位置,[position]);
返回值为布尔值

str.endsWith(表示该字符是否在尾部或者指定位置,str的长度/默认为str.length);
表示的是该字符是否在该位置的末尾  后面的参数 str.length 为要比较的字符串的长度

str.repear(要重复的次数);  不算本身 次数为多少就是多少次

6.------------------------------------------------------------------------------------------------------------------------------------------------
ES 6降级处理
7.---------------------------------------------------------------------------------------------
CMD切换盘 d:
cd 进入当前目录
shift+右键 power shell

垃圾回收机制

