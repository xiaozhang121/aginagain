1.---------------------------------------------------------------------------------------------
两大编程思想:
1面向过程(POP):先分析出步骤 然后用函数一步一步实现 然后依次调用/第一步,第二步,第三步...
2面向对象(OPP):把事务分解成一个个对象,然后由对象之间分工合作/对象之间互相调用属性方法产生关联
面向对象三大特性:
封装 继承 多态
2.---------------------------------------------------------------------------------------------
ES6中的对象:
类:种类;
对象:具体到某一个事物;
3.---------------------------------------------------------------------------------------------
创建类:
跟自定义函数创造对象的区别?
class Person {}
class Dog{}

obj instanceof Object;查看是不是对象;返回值是布尔值;
var obj = new Person();实例化对象

属性放入构造函数中 方法往下顺着写不加符号;
class Star {
	//constructor本来前面有function 相当于一个函数 在类中需要隐藏function
	constructor(uname,age) {
	this.name = uname;
	this.nianling = age; 
	//this当前实例对象
	
	//添加方法不加逗号
	console.log(this)
	sing () {
	console.log(this.uname+'唱歌');
	}
	dance{}

}
}
var mm = new Star('刘德华',22);
new Star('刘德华',22);

函数没有返回值 返回的是undefined;


构造函数开始就执行;
4.---------------------------------------------------------------------------------------------
继承:
一个类继承另一个类的属性和方法;

class Father {
construtor(uname,age){
this.name = uname;
this.age = age;
qian (){
log(111)
}
}
}

class Son extends Father {
//如果儿子也有自己的属性 那么就继承不到父亲的属性 因为this的指向不同;
//此时要继承到父亲的属性/方法 则需要使用super()参数为父亲的参数;
//子类和父类都有同样的方法 那么调用的是儿子的 如果两个都调用 需要用super.方法();
super(uname,age);
this.fenshu = score;

qian(){
super.qian();
log(222);
}
}
var obj = new Son('儿子',16);
console.log(obj);
5.---------------------------------------------------------------------------------------------
ES6注意问题
没有预解析 必须先有类 在实例化对象;
类里面需要使用属性 必须要用 this

constcotr中的this指的是实例化对象
方法中的this指向的是调用者;
6..---------------------------------------------------------------------------------------------
添加元素的高级方法:
element.insertAdjacentHTML(position,text);支持添加字符串标签;
position:'beforebegin'放在element的前面;
afterbegin 内部第一个子节点之前
beforeend内部最后一个子节点之后
7.---------------------------------------------------------------------------------------------
document.getelementbyTagName/动态选择器 可以直接获取页面上所有的标签/随时监测页面上有没有这个元素
8.---------------------------------------------------------------------------------------------
字面量创建对象
var obj = {
uname:'阿飞',
age:'22'
fei:function (){}
//键值对
//对象:成员
//函数是一个特殊的值 如果不加括号 输出的就是整个函数
//访问属性的另一种方式:对象['属性'];
}
获取对象中所有的成员
遍历对象
for (var key/对象的每一个键名 in obj/对象名) {
不能用.key会直接访问.key这个属性其实并没有
log(obj[key]);
}

判断属性:
for (var key in obj) {
            if (key == 'age') {
                console.log(obj[key]);
            }

9.---------------------------------------------------------------------------------------------
new 在执行时会发生四件事:
1.在内存中创建一个新对象
2.让this指向这个对象
3.执行构造函数里面的代码.给这个新对象添加属性和方法
4.返回这个新对象(所以构造函数里面不需要return)
10.---------------------------------------------------------------------------------------------
*********************************************************************************************************静态成员和实例成员
functon Person(name,age){
this.name = name;
this.age =age;
//实例成员
}
//静态成员
Person.sex = '男';

静态成员只能由构造函数访问;
实例成员只能由实例对象访问;
11.---------------------------------------------------------------------------------------------***************************************************************************************
构造函数原型prototype:
**每一个构造函数都有一个属性,prototype指向一个对象(__proto__),prototype就是一个对象;**

Star.prototype.say

Star.prototype是一个对象

所有的公共属性写到构造函数里 所有的公共方法写到原型对象中
12.---------------------------------------------------------------------------------------------***************************************************************************************
对象原型__proto__;
是一个非标准属性,不可以拿来赋值或者复制;

**对象原型:是对象的一个属性;**

对象原型的作用是为了指向原型对象(__proto__-->prototype);

为什么实例对象能用到原型对象上的方法?
因为每个对象都有__proto__;


                                          Star构造函数-------Star.prototype(构造函数的一个属性)------------->原型对象(prototype)(每一个对象都有一个属性,原型__proto__)
                                                      |                                                                                                    /
                                                      |                                                                                                   /
                                                      |                                                                                                  /
                                                      |                                                                                                 /
                                                      |<----------------------.prototype.constructor--------------------/
                                                      |                                                                                              /
                                                      |                                                                                             /
                                                      |                                                                                           /
                                                      |                                                                                         /
                                                      |                                                                                       /
                                       实例化对象(__proto__)(可以访问到原型对象中的方法)(__proto__相当于这个实例化对象中的一个属性)
function Person(){}

Person.prototype.say = function(){}//向构造函数的原型对象中添加一个方法;
Person.prototype.constructor//是构造函数的一个属性,指回构造函数本身;

var n = new Person(){};//实例化对象 此时n的原型指向了原型对象;


所以此时:

Person.prototype ==n.__proto___;
n.__proto__.constructor//所以也是指回构造函数本身
13.---------------------------------------------------------------------------------------------***************************************************************************************
constructor构造函数 是一个属性 prototype的一个属性

.prototype.cnstructor 再指回构造函数本身 


14.---------------------------------------------------------------------------------------------***************************************************************************************
Star.prototype = {}//这么写会覆盖,相当于赋值,会将构造函数覆盖

//自己再从新写入一个构造函数
Star.prototype = {
constructor : Star,
chang : function (){},
}
为什么要在写个构造器?
如果不写会被后面的方法覆盖 访问不到原型
15.---------------------------------------------------------------------------------------------***************************************************************************************
arr.reverse();反转数组

console.log( Array.prototype );
	// 添加求和方法
	Array.prototype.sum = function () {
		var sum = 0;
		for (var i = 0; i < this.length; i++) {
			sum += this[i];
		}
		return sum;
	}

	var arr = [1,2,3];
	console.log( arr.sum() );

	var newArr = [6,7,8,9];
	console.log( newArr.sum() );

16.---------------------------------------------------------------------------------------------
Math是以字面量形式穿创建的,所以不用加new,其他的系统构造函数都是以构造函数形式创建的
var Math = {};
其他的Date,String,Boolean都是需要new  只不过被隐式包装了
17.---------------------------------------------------------------------------------------------
function fn(){}

window.fn();

普通函数中的this指向window;

改变this的指向: .call(对象,自定义函数中原本的参数)
第一个参数为fn要指向的对象
fn.call(obj,num1,num2);
18.---------------------------------------------------------------------------------------------
ES5:组合继承(ES5中没有extends);
 
function Father(uname,age) {

this.uname = uname;

this.age = age;
}
+++++++++++++++++++++++++++++++++++++++
function Son(uname,age,score){

X-->Father(uname,age)//无法继承 因为this指向改变了

Father.call(this,uname,age);

this.score = score;

}
var obj = new Son('儿子',13,99);

方法之间赋值的是地址,所以一个添加了新的方法另一个也添加了;
要想继承方法:

把父类的实例对象赋值给子类的原型对象;

对象赋值给另一个对象会覆盖 需要再写一个constructor指回去
19.---------------------------------------------------------------------------------------------
遍历数组:

1.forEach();

第一个参数为当前项;
第二个参数为索引下标;
第三个为当前遍历的数组的本身;
var arr = ['red','blue','yellow','pink'];

arr.forEach(function(val,i,obj){

console.log(val,i,obj);

});
2.filter();**************************************************************************可以进行筛选(返回的是满足要求的新数组)

var arr = ['red','blue','yellow','pink'];

var result = arr.filter(function(val,i,obj){

//参数和上面的一样;
console.log(val,i,obj)
//但是可以进行数组筛选
return val == 'red';

});
console.log(result);

3.some();************************************************************************可以进行查找(返回的是布尔值,找到了立刻停止)

var arr = [1,5,3,6,9,8,7];
var re = arr.some(function(val,index,obj){
return val==67;
});

console.log(re);

//遇到return true停止;
 var arr = [1, 5, 3, 6, 9, 8, 7];
        var newarr = [];
        arr.some(function (val, index, obj) {
            // console.log(val);
            console.log(index);

            if (val == 3) {
                newarr.push(val);
                return true;
            }

        });
        console.log(newarr);

4.map();
5.every();
20.---------------------------------------------------------------------------------------------
发生改变
xx.onchang = function(){}
21.---------------------------------------------------------------------------------------------
字符串的方法:
var str = ' khhdjdjaj ';
空格在字符串中占位置,占长度;
str.trim();去除空格/不能去除中间的空格
22.---------------------------------------------------------------------------------------------
自调用函数:
(function(){console.log('内容')})();

(funct(a.b){console.log(a,b)})(a的实参,b的实参);

创建对象:
var fn = new Functon('n','m','console.log(n,m)');
fn('aaa','bbb');
函数也是对象;
23.---------------------------------------------------------------------------------------------
函数的调用方式
普通函数
fn();

方法
var obj = {
hs:function(){}
}
obj.hs();

构造函数
function Person(){}
new Person();

绑定事件
btn.onclick = function(){}

定时器
window.serInterval(function(){},1000);

自调用函数
(function(){})();
相当于
var obj = function (){};
obj();
24.---------------------------------------------------------------------------------------------
this的指向:
普通函数调用:window
构造函数调用:实例对象
对象方法调用:该方法所属对象
事件绑定方法:绑定事件对象/事件源
定时器函数:window
立即执行函数:window
25.---------------------------------------------------------------------------------------------
*************************************************************************************************************改变函数内部this指向:

.call***********************一般在继承中常见/会调用函数/参数为若干个参数
var obj = {
name : '阿飞',
age : 22,
fei : function(){
console.log(this);
}
}

var objN = {name:'aa',age:22}
obj.fei.call(objN);

.apply*********************一般在数组中常见/参数为一个数组
fn.apply(需指向的对象,[数组]);
function fn(a,b){console.log(this,a,b)};
var obj = {name:'a',age:22};
fn.apply(obj,['aaa','bbb']);
与.call区别:第二个参数必须使用数组 将参数装进数组中
var arr = [1,2,3,4,5,6,7];
var n = Math.max.apply(arr,arr);
console.log(n)

 var m = Math.max(1, 2, 3, 4, 5, 6, 7);
 console.log(m);

.bind************************和call相同 但是不调用函数
function fn(){
console.log(this);
}
var obj = {name:'aa',age:22};
fn.bind(obj);没有输出 因为不调用函数
var fn = fn.bind(obj);
fn();需要定义个变量接收再调用

var btn = document.querySelector('input');
btn.onclick = function(){
this.disabled = true;

//函数改变的this指向!要改函数的this指向
window.setTimeout(function(){//此时的this指向的是window
this.disabled = false;
}.bind(this),3000);
}

26.---------------------------------------------------------------------------------------------

开启严格模式:
"use strict";写在第一句话 否则严格模式不生效
严格模式中 全局作用域下的函数的this指向的是undefined;
严格模式中参数不可以重名

function fn(a,a) {
//var a = 1;//var a = 2;会覆盖a = 1;
console.log(a+a);
}
输出为4

27.---------------------------------------------------------------------------------------------
高阶函数:把函数当为参数的函数 称为高阶函数  被当做参数的函数称为回调函数;
函数是一个特殊值;
逻辑与:&&;
按位与:&;

把函数当为返回值的函数也叫高阶函数
28.---------------------------------------------------------------------------------------------
变量作用域:
(closure)闭包:有权访问父作用域的函数;

function f(){
var a = 3;
   function b() {
console.log(a);
}
b();
}
f();
在函数外访问到了该变量 就叫做闭包;

如果函数内部有闭包 这该函数内的变量执行完后不删除,留下来的函数称为闭包函数;

 function a() {
            var num = 6;
            return function b() {
                console.log(num);
            }
        }
        var re = a();
        re();

29.---------------------------------------------------------------------------------------------
递归:
最先调用的函数最后执行;
30.---------------------------------------------------------------------------------------------
求1-n的阶乘
 
function jC(n) {
if (n==1) {
return 1};
return n*jC(n-1)
}
31.---------------------------------------------------------------------------------------------
斐波那契数列
function fb(n) {
            if (n == 1 || n == 2) {
                return 1;
            }
            fb(n - 1) + fb(n - 2);
        }
        //fb(3-1)+fb(3-2);
        //fb(2)+fb(1);
        //fb(1)+1+fb(1);
        //3
32.--------------------------------------------------------------------------------------------
基本数据类型:
number、string、boolean、null、undefined、symbol

深拷贝:
当引用类型进行赋值的时候 实际上赋值的是地址值;
当一边的数据改变时 另一边的地址也必然发生改变;
深拷贝就是
33.-----------------------------------------------------------------------------------------------
append prepend before after            appendTo  prependTo  insertAfter   insertBefore

.toString();将所有的数据转换成为字符串,null undefined除外;
.toString/arguments用法

34.------------------------------------------------------------------------------------------------
JSON是一种轻量级数据交换(存储)格式
类型没有函数和undefined,对象属性名必须有双引号包裹;

JSON.parse();//将JSON格式的字符串转换成js对象
JSON.stringify();//将js对象转换成为JSON格式的字符串

使用原生js的时候就不需要转换了;






